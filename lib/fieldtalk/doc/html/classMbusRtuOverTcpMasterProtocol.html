<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<title>FieldTalk Modbus Master C++ Library: MbusRtuOverTcpMasterProtocol Class Reference</title>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<style>
h2 a, h3 a {font-weight:bold; color:black;}
h2 a:hover, h3 a:hover {text-decoration:none;}
</style>
</head><body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Introduction</span></a></li>
      <li><a href="pages.html"><span>Chapters</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>MbusRtuOverTcpMasterProtocol Class Reference<br/>
<small>
[<a class="el" href="group__mbusmastertcp.html">TCP/IP Protocols</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MbusRtuOverTcpMasterProtocol" --><!-- doxytag: inherits="MbusTcpMasterProtocol" -->
<p>Encapsulated Modbus RTU Master Protocol class.  
<a href="#_details">More...</a></p>
<div class="dynheader">
Inheritance diagram for MbusRtuOverTcpMasterProtocol:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classMbusRtuOverTcpMasterProtocol.png" usemap="#MbusRtuOverTcpMasterProtocol_map" alt=""/>
  <map id="MbusRtuOverTcpMasterProtocol_map" name="MbusRtuOverTcpMasterProtocol_map">
<area href="classMbusTcpMasterProtocol.html" alt="MbusTcpMasterProtocol" shape="rect" coords="0,56,197,80"/>
<area href="classMbusMasterFunctions.html" alt="MbusMasterFunctions" shape="rect" coords="0,0,197,24"/>
</map>
</div>

<p><a href="classMbusRtuOverTcpMasterProtocol-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7539d64e1eaffd2b8b69ef2f311bde57"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::MbusRtuOverTcpMasterProtocol" ref="a7539d64e1eaffd2b8b69ef2f311bde57" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusRtuOverTcpMasterProtocol.html#a7539d64e1eaffd2b8b69ef2f311bde57">MbusRtuOverTcpMasterProtocol</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a <a class="el" href="classMbusRtuOverTcpMasterProtocol.html" title="Encapsulated Modbus RTU Master Protocol class.">MbusRtuOverTcpMasterProtocol</a> object and initialises its data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusRtuOverTcpMasterProtocol.html#a4bd515ba5c6f5949a59673d0dbb54607">openProtocol</a> (const TCHAR *const hostName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connects to a Encapsulated Modbus RTU slave.  <a href="#a4bd515ba5c6f5949a59673d0dbb54607"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusRtuOverTcpMasterProtocol.html#a02da0a41e144f4fa9bc7f71e8b240a65">setPort</a> (unsigned short portNo)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the TCP port number to be used by the protocol.  <a href="#a02da0a41e144f4fa9bc7f71e8b240a65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99162acbde11d57faf6a154089e920cb"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::closeProtocol" ref="a99162acbde11d57faf6a154089e920cb" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusTcpMasterProtocol.html#a99162acbde11d57faf6a154089e920cb">closeProtocol</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes a TCP/IP connection to a slave and releases any system resources associated with the connection. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusTcpMasterProtocol.html#a9afd5447128f5afa40faac33c7219b50">isOpen</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the protocol is open or not.  <a href="#a9afd5447128f5afa40faac33c7219b50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusTcpMasterProtocol.html#a9d3bcbf1077c7afa410f48f37ecd52f3">getPort</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the TCP port number used by the protocol.  <a href="#a9d3bcbf1077c7afa410f48f37ecd52f3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Bit Access</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp9c6594861145785dabcf166c3b3245cd"></a>Table 0:00000 (Coils) and Table 1:0000 (Input Status) </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#ac9cc7e597a6c7036746a15e159d05341">readCoils</a> (int slaveAddr, int startRef, int bitArr[], int refCnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 1, Read Coil Status/Read Coils.  <a href="#ac9cc7e597a6c7036746a15e159d05341"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#afc2ba1cf568c7e9a1848a4a99b148604">readInputDiscretes</a> (int slaveAddr, int startRef, int bitArr[], int refCnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 2, Read Inputs Status/Read Input Discretes.  <a href="#afc2ba1cf568c7e9a1848a4a99b148604"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#af47fb8f22703b1c270d243a17dd7b0be">writeCoil</a> (int slaveAddr, int bitAddr, int bitVal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 5, Force Single Coil/Write Coil.  <a href="#af47fb8f22703b1c270d243a17dd7b0be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a93b382d702ce98a2224a13d98edeb47a">forceMultipleCoils</a> (int slaveAddr, int startRef, const int bitArr[], int refCnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 15 (0F Hex), Force Multiple Coils.  <a href="#a93b382d702ce98a2224a13d98edeb47a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
16-bit Access</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp59f9c3acfc506cb69a200ece27d6b875"></a>Table 4:00000 (Holding Registers) and Table 3:00000 (Input Registers) </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#aea74f35a7305faf154b3ee7a46d926f7">readMultipleRegisters</a> (int slaveAddr, int startRef, short regArr[], int refCnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 3, Read Holding Registers/Read Multiple Registers.  <a href="#aea74f35a7305faf154b3ee7a46d926f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a41c4552c71b03351858a0cdea97654b6">readInputRegisters</a> (int slaveAddr, int startRef, short regArr[], int refCnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 4, Read Input Registers.  <a href="#a41c4552c71b03351858a0cdea97654b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a87c4cbb3073f7caa117e1745e9de731b">writeSingleRegister</a> (int slaveAddr, int regAddr, short regVal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 6, Preset Single Register/Write Single Register.  <a href="#a87c4cbb3073f7caa117e1745e9de731b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a8ba7b9150d6b642f44ff1f94679e0dc4">writeMultipleRegisters</a> (int slaveAddr, int startRef, const short regArr[], int refCnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 16 (10 Hex), Preset Multiple Registers/Write Multiple Registers.  <a href="#a8ba7b9150d6b642f44ff1f94679e0dc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#acd2f5ad4e7b1d81f203ffaf860434ee9">maskWriteRegister</a> (int slaveAddr, int regAddr, short andMask, short orMask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 22 (16 Hex), Mask Write Register.  <a href="#acd2f5ad4e7b1d81f203ffaf860434ee9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#ac6142b852a7760f72daf2ec649f986b0">readWriteRegisters</a> (int slaveAddr, int readRef, short readArr[], int readCnt, int writeRef, const short writeArr[], int writeCnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 23 (17 Hex), Read/Write Registers.  <a href="#ac6142b852a7760f72daf2ec649f986b0"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
32-bit Access</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp5e22369ce906d152383d4cc7f22b45de"></a>Table 4:00000 (Holding Registers) and Table 3:00000 (Input Registers) </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a302b75ea21b9600e30ac68bcf81f64aa">readMultipleLongInts</a> (int slaveAddr, int startRef, int int32Arr[], int refCnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 3 for 32-bit long int data types, Read Holding Registers/Read Multiple Registers as long int data.  <a href="#a302b75ea21b9600e30ac68bcf81f64aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a3b323a95f0220f08fb6eec0a0958ea3f">readInputLongInts</a> (int slaveAddr, int startRef, int int32Arr[], int refCnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 4 for 32-bit long int data types, Read Input Registers as long int data.  <a href="#a3b323a95f0220f08fb6eec0a0958ea3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a839f8346ae1b9f4b7fdc7a056789cc83">writeMultipleLongInts</a> (int slaveAddr, int startRef, const int int32Arr[], int refCnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 16 (10 Hex) for 32-bit long int data types, Preset Multiple Registers/Write Multiple Registers with long int data.  <a href="#a839f8346ae1b9f4b7fdc7a056789cc83"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#acf8eae638c2ce090d5a9fbabfbb065fa">readMultipleFloats</a> (int slaveAddr, int startRef, float float32Arr[], int refCnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 3 for 32-bit float data types, Read Holding Registers/Read Multiple Registers as float data.  <a href="#acf8eae638c2ce090d5a9fbabfbb065fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a3ec38f6a93fc0027258e4e43c3a68b43">readInputFloats</a> (int slaveAddr, int startRef, float float32Arr[], int refCnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 4 for 32-bit float data types, Read Input Registers as float data.  <a href="#a3ec38f6a93fc0027258e4e43c3a68b43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a40b6b3ba4f302a9e62e82b754913bfff">writeMultipleFloats</a> (int slaveAddr, int startRef, const float float32Arr[], int refCnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 16 (10 Hex) for 32-bit float data types, Preset Multiple Registers/Write Multiple Registers with float data.  <a href="#a40b6b3ba4f302a9e62e82b754913bfff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a17196f562a8789d125329ea668589e6b">readMultipleMod10000</a> (int slaveAddr, int startRef, int int32Arr[], int refCnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 3 for 32-bit modulo-10000 long int data types, Read Holding Registers/Read Multiple Registers as modulo-10000 long int data.  <a href="#a17196f562a8789d125329ea668589e6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a38d66906420d8f74d20b39fa3b1ade57">readInputMod10000</a> (int slaveAddr, int startRef, int int32Arr[], int refCnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 4 for 32-bit modulo-10000 long int data types, Read Input Registers as modulo-10000 long int data.  <a href="#a38d66906420d8f74d20b39fa3b1ade57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a7f5974d79eb38d639c76e4c640de0cbc">writeMultipleMod10000</a> (int slaveAddr, int startRef, const int int32Arr[], int refCnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 16 (10 Hex) for 32-bit modulo-10000 long int data types, Preset Multiple Registers/Write Multiple Registers with modulo-10000 long int data.  <a href="#a7f5974d79eb38d639c76e4c640de0cbc"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Diagnostics</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp36b64aad8a26246fe3ad4116a2b6f289"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a751949db73e8409dca8409b108aee2ae">readExceptionStatus</a> (int slaveAddr, unsigned char *statusBytePtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function 7, Read Exception Status.  <a href="#a751949db73e8409dca8409b108aee2ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#acdd4287c493dda9db1995ea86139328f">returnQueryData</a> (int slaveAddr, const unsigned char queryArr[], unsigned char echoArr[], int len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function code 8, sub-function 00, Return Query Data.  <a href="#acdd4287c493dda9db1995ea86139328f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a52e7edd849a2b1f7c29ac9517bdd1d3d">restartCommunicationsOption</a> (int slaveAddr, int clearEventLog)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modbus function code 8, sub-function 01, Restart Communications Option.  <a href="#a52e7edd849a2b1f7c29ac9517bdd1d3d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Custom Function Codes</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpb19ac7801439666718b34e662d43ca20"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devicespecific.html#gaea9132747bc347fe286d9f7f66d96ee1">customFunction</a> (int slaveAddr, int functionCode, void *requestData, size_t requestLen, void *responseData, size_t *responseLenPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User Defined Function CodeThis method can be used to implement User Defined Function Codes.  <a href="group__devicespecific.html#gaea9132747bc347fe286d9f7f66d96ee1"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Protocol Configuration</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp2dfe70381056cf3bab1e3447c7d48b78"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a0649ac6aee01f23c07b9b747f3d33d1d">setTimeout</a> (int timeOut)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures time-out.  <a href="#a0649ac6aee01f23c07b9b747f3d33d1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a556668ae26748c5d696c34d3915e08d8">getTimeout</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the time-out value.  <a href="#a556668ae26748c5d696c34d3915e08d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a439626d88c98d2941978b1decb114984">setPollDelay</a> (int pollDelay)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures poll delay.  <a href="#a439626d88c98d2941978b1decb114984"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#ac5298559d8c7d33668e770b28c302455">getPollDelay</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the poll delay time.  <a href="#ac5298559d8c7d33668e770b28c302455"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a7a86879ac5b1dcf109a1d1ea8f2e3f0a">setRetryCnt</a> (int retryCnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures the automatic retry setting.  <a href="#a7a86879ac5b1dcf109a1d1ea8f2e3f0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a4679ad5a7cde6025d751b0632f21cec6">getRetryCnt</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the automatic retry count.  <a href="#a4679ad5a7cde6025d751b0632f21cec6"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Transmission Statistic Functions</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp60325724f5f909d00bf3e7670a0e248d"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#ad1bbef1bb8daa45af22ce3c6983abce0">getTotalCounter</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns how often a message transfer has been executed.  <a href="#ad1bbef1bb8daa45af22ce3c6983abce0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c3fd2d33b99f9d2da1c9b2b55f449ae"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::resetTotalCounter" ref="a3c3fd2d33b99f9d2da1c9b2b55f449ae" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a3c3fd2d33b99f9d2da1c9b2b55f449ae">resetTotalCounter</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets total message transfer counter. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#aa5f7d2ae6cb4ed984ea3b637d3fb4b16">getSuccessCounter</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns how often a message transfer was successful.  <a href="#aa5f7d2ae6cb4ed984ea3b637d3fb4b16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad98ce1889de0c373310bf805754d5354"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::resetSuccessCounter" ref="ad98ce1889de0c373310bf805754d5354" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#ad98ce1889de0c373310bf805754d5354">resetSuccessCounter</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets successful message transfer counter. <br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Slave Configuration</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpbcddd32fe242582de61795303f5cde9c"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a6d82a9ee44f44c8f6a7a19a652315c76">configureBigEndianInts</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures 32-bit int data type functions to do a word swap.  <a href="#a6d82a9ee44f44c8f6a7a19a652315c76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#aebdf07bc15ac25499253c821651d063b">configureBigEndianInts</a> (int slaveAddr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables int data type functions to do a word swap on a per slave basis.  <a href="#aebdf07bc15ac25499253c821651d063b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#abbc17750cdbd2129d8942170ccb14b0f">configureLittleEndianInts</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures 32-bit int data type functions not to do a word swap.  <a href="#abbc17750cdbd2129d8942170ccb14b0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a0436a1d520aab4d036e5ceb37511a467">configureLittleEndianInts</a> (int slaveAddr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disables word swapping for int data type functions on a per slave basis.  <a href="#a0436a1d520aab4d036e5ceb37511a467"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a16e0221a03f033b8bfe15f8b09c99116">configureIeeeFloats</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures float data type functions not to do a word swap.  <a href="#a16e0221a03f033b8bfe15f8b09c99116"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a64b84ced2ebcbd3e91000b6fca74af94">configureIeeeFloats</a> (int slaveAddr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disables float data type functions to do a word swap on a per slave basis.  <a href="#a64b84ced2ebcbd3e91000b6fca74af94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a64bd8d4a1c2ab7addee3af912b107ea0">configureSwappedFloats</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures float data type functions to do a word swap.  <a href="#a64bd8d4a1c2ab7addee3af912b107ea0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a1b0d3e8e4d5d25ce75cfa648dff74218">configureSwappedFloats</a> (int slaveAddr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables float data type functions to do a word swap on a per slave basis.  <a href="#a1b0d3e8e4d5d25ce75cfa648dff74218"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a27d2907a8eafa965e3e1c701c7ba67bc">configureStandard32BitMode</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures all slaves for Standard 32-bit Mode.  <a href="#a27d2907a8eafa965e3e1c701c7ba67bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a1de5e0b6a1dd522b00203ab602e7b028">configureStandard32BitMode</a> (int slaveAddr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures a slave for Standard 32-bit Register Mode.  <a href="#a1de5e0b6a1dd522b00203ab602e7b028"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a61e1bd556bba1708e1465a44ad8701cc">configureEnron32BitMode</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures all slaves for Daniel/ENRON 32-bit Mode.  <a href="#a61e1bd556bba1708e1465a44ad8701cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a2010cf27a82c4ab4f82e2ecf32466dd2">configureEnron32BitMode</a> (int slaveAddr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures all slaves for Daniel/ENRON 32-bit Mode.  <a href="#a2010cf27a82c4ab4f82e2ecf32466dd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a3de968ddddba3bf894ac8b5a154eb720">configureCountFromOne</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures the reference counting scheme to start with one for all slaves.  <a href="#a3de968ddddba3bf894ac8b5a154eb720"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#ad4f702a085577c924e63388b5a9a5d62">configureCountFromOne</a> (int slaveAddr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures a slave's reference counting scheme to start with one.  <a href="#ad4f702a085577c924e63388b5a9a5d62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a7e541835ede7552fa6f603e5263d8c97">configureCountFromZero</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures the reference counting scheme to start with zero for all slaves.  <a href="#a7e541835ede7552fa6f603e5263d8c97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a35d29523ba52fe3df3a92858957ea49e">configureCountFromZero</a> (int slaveAddr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures a slave's reference counting scheme to start with zero.  <a href="#a35d29523ba52fe3df3a92858957ea49e"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Utility Functions</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpfba3b3bfd659318e3268e1e03ca5cb8e"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const TCHAR *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMbusMasterFunctions.html#a663f47b96550118a11ef583bc33e27bf">getPackageVersion</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the library version number.  <a href="#a663f47b96550118a11ef583bc33e27bf"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Encapsulated Modbus RTU Master Protocol class. </p>
<p>This class realises the Encapsulated Modbus RTU master protocol. This protocol is also known as RTU over TCP or RTU/IP and used for example by ISaGraf Soft-PLCs. This class provides functions to establish and to close a TCP/IP connection to the slave as well as data and control functions which can be used after a connection to a slave device has been established successfully. The data and control functions are organized different conformance classes. For a more detailed description of the data and control functions see section <a class="el" href="group__mbusmaster.html">Data and Control Functions for all Modbus Protocol Flavours</a>.</p>
<p>It is also possible to instantiate multiple instances of this class for establishing multiple connections to either the same or different hosts.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__mbusmaster.html" title="This Modbus protocol library implements the most commonly used data functions as well as some control...">Data and Control Functions for all Modbus Protocol Flavours</a>, <a class="el" href="group__mbusmastertcp.html" title="The library provides two flavours of TCP/IP based Modbus protocols.">TCP/IP Protocols</a> </dd>
<dd>
<a class="el" href="classMbusMasterFunctions.html" title="Base class which implements Modbus data and control functions.">MbusMasterFunctions</a> </dd>
<dd>
<a class="el" href="classMbusSerialMasterProtocol.html" title="Base class for serial serial master protocols.">MbusSerialMasterProtocol</a>, <a class="el" href="classMbusRtuMasterProtocol.html" title="Modbus RTU Master Protocol class.">MbusRtuMasterProtocol</a>, <a class="el" href="classMbusAsciiMasterProtocol.html" title="Modbus ASCII Master Protocol class.">MbusAsciiMasterProtocol</a> </dd>
<dd>
<a class="el" href="classMbusTcpMasterProtocol.html" title="MODBUS/TCP Master Protocol class.">MbusTcpMasterProtocol</a> </dd></dl>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4bd515ba5c6f5949a59673d0dbb54607"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::openProtocol" ref="a4bd515ba5c6f5949a59673d0dbb54607" args="(const TCHAR *const hostName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int openProtocol </td>
          <td>(</td>
          <td class="paramtype">const TCHAR *const &nbsp;</td>
          <td class="paramname"> <em>hostName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connects to a Encapsulated Modbus RTU slave. </p>
<p>This function establishes a logical network connection between master and slave. After a connection has been established data and control functions can be used. A TCP/IP connection should be closed if it is no longer needed.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The default time-out for the connection is 1000 ms. </dd>
<dd>
The default TCP port number is 1100. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hostName</em>&nbsp;</td><td>String with IP address or host name </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>

<p>Reimplemented from <a class="el" href="classMbusTcpMasterProtocol.html#a4bd515ba5c6f5949a59673d0dbb54607">MbusTcpMasterProtocol</a>.</p>

</div>
</div>
<a class="anchor" id="a02da0a41e144f4fa9bc7f71e8b240a65"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::setPort" ref="a02da0a41e144f4fa9bc7f71e8b240a65" args="(unsigned short portNo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int setPort </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>portNo</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the TCP port number to be used by the protocol. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Usually the port number remains unchanged and defaults to 1100. In this case no call to this function is necessary. However if the port number has to be different from 1100 this function must be called <em>before</em> opening the connection with openProtocol().</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>portNo</em>&nbsp;</td><td>Port number to be used when opening the connection </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>FTALK_SUCCESS</em>&nbsp;</td><td>Success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FTALK_ILLEGAL_STATE_ERROR</em>&nbsp;</td><td>Protocol already open </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classMbusTcpMasterProtocol.html#a02da0a41e144f4fa9bc7f71e8b240a65">MbusTcpMasterProtocol</a>.</p>

</div>
</div>
<a class="anchor" id="a9afd5447128f5afa40faac33c7219b50"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::isOpen" ref="a9afd5447128f5afa40faac33c7219b50" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isOpen </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the protocol is open or not. </p>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>true</em>&nbsp;</td><td>= open </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>false</em>&nbsp;</td><td>= closed </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMbusMasterFunctions.html#a9082a81567332cc8e12e51363ba4edac">MbusMasterFunctions</a>.</p>

</div>
</div>
<a class="anchor" id="a9d3bcbf1077c7afa410f48f37ecd52f3"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::getPort" ref="a9d3bcbf1077c7afa410f48f37ecd52f3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short getPort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the TCP port number used by the protocol. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Port number used by the protocol </dd></dl>

</div>
</div>
<a class="anchor" id="ac9cc7e597a6c7036746a15e159d05341"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::readCoils" ref="ac9cc7e597a6c7036746a15e159d05341" args="(int slaveAddr, int startRef, int bitArr[], int refCnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int readCoils </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bitArr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>refCnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function 1, Read Coil Status/Read Coils. </p>
<p>Reads the contents of the discrete outputs (coils, 0:00000 table).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 65536) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bitArr</em>&nbsp;</td><td>Buffer which will contain the data read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of coils to be read (Range: 1-2000) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>

</div>
</div>
<a class="anchor" id="afc2ba1cf568c7e9a1848a4a99b148604"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::readInputDiscretes" ref="afc2ba1cf568c7e9a1848a4a99b148604" args="(int slaveAddr, int startRef, int bitArr[], int refCnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int readInputDiscretes </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bitArr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>refCnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function 2, Read Inputs Status/Read Input Discretes. </p>
<p>Reads the contents of the discrete inputs (input status, 1:00000 table).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 65536) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bitArr</em>&nbsp;</td><td>Buffer which will contain the data read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of coils to be read (Range: 1-2000) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>

</div>
</div>
<a class="anchor" id="af47fb8f22703b1c270d243a17dd7b0be"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::writeCoil" ref="af47fb8f22703b1c270d243a17dd7b0be" args="(int slaveAddr, int bitAddr, int bitVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int writeCoil </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bitAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bitVal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function 5, Force Single Coil/Write Coil. </p>
<p>Sets a single discrete output variable (coil, 0:00000 table) to either ON or OFF.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 0 - 255) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bitAddr</em>&nbsp;</td><td>Coil address (Range: 1 - 65536) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bitVal</em>&nbsp;</td><td>true sets, false clears discrete output variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Broadcast supported for serial protocols </dd></dl>

</div>
</div>
<a class="anchor" id="a93b382d702ce98a2224a13d98edeb47a"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::forceMultipleCoils" ref="a93b382d702ce98a2224a13d98edeb47a" args="(int slaveAddr, int startRef, const int bitArr[], int refCnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int forceMultipleCoils </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>bitArr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>refCnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function 15 (0F Hex), Force Multiple Coils. </p>
<p>Writes binary values into a sequence of discrete outputs (coils, 0:00000 table).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 0 - 255) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 65536) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bitArr</em>&nbsp;</td><td>Buffer which contains the data to be sent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of coils to be written (Range: 1-1968) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Broadcast supported for serial protocols </dd></dl>

</div>
</div>
<a class="anchor" id="aea74f35a7305faf154b3ee7a46d926f7"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::readMultipleRegisters" ref="aea74f35a7305faf154b3ee7a46d926f7" args="(int slaveAddr, int startRef, short regArr[], int refCnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int readMultipleRegisters </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>regArr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>refCnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function 3, Read Holding Registers/Read Multiple Registers. </p>
<p>Reads the contents of the output registers (holding registers, 4:00000 table).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start register (Range: 1 - 65536) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regArr</em>&nbsp;</td><td>Buffer which will be filled with the data read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of registers to be read (Range: 1-125) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>

</div>
</div>
<a class="anchor" id="a41c4552c71b03351858a0cdea97654b6"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::readInputRegisters" ref="a41c4552c71b03351858a0cdea97654b6" args="(int slaveAddr, int startRef, short regArr[], int refCnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int readInputRegisters </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>regArr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>refCnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function 4, Read Input Registers. </p>
<p>Read the contents of the input registers (3:00000 table).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start register (Range: 1 - 65536) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regArr</em>&nbsp;</td><td>Buffer which will be filled with the data read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of registers to be read (Range: 1-125) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>

</div>
</div>
<a class="anchor" id="a87c4cbb3073f7caa117e1745e9de731b"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::writeSingleRegister" ref="a87c4cbb3073f7caa117e1745e9de731b" args="(int slaveAddr, int regAddr, short regVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int writeSingleRegister </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>regVal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function 6, Preset Single Register/Write Single Register. </p>
<p>Writes a value into a single output register (holding register, 4:00000 reference).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 0 - 255) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regAddr</em>&nbsp;</td><td>Register address (Range: 1 - 65536) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regVal</em>&nbsp;</td><td>Data to be sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Broadcast supported for serial protocols </dd></dl>

</div>
</div>
<a class="anchor" id="a8ba7b9150d6b642f44ff1f94679e0dc4"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::writeMultipleRegisters" ref="a8ba7b9150d6b642f44ff1f94679e0dc4" args="(int slaveAddr, int startRef, const short regArr[], int refCnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int writeMultipleRegisters </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short&nbsp;</td>
          <td class="paramname"> <em>regArr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>refCnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function 16 (10 Hex), Preset Multiple Registers/Write Multiple Registers. </p>
<p>Writes values into a sequence of output registers (holding registers, 4:00000 table).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 0 - 255) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start register (Range: 1 - 65536) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regArr</em>&nbsp;</td><td>Buffer with the data to be sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of registers to be written (Range: 1-123) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Broadcast supported for serial protocols </dd></dl>

</div>
</div>
<a class="anchor" id="acd2f5ad4e7b1d81f203ffaf860434ee9"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::maskWriteRegister" ref="acd2f5ad4e7b1d81f203ffaf860434ee9" args="(int slaveAddr, int regAddr, short andMask, short orMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int maskWriteRegister </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>andMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>orMask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function 22 (16 Hex), Mask Write Register. </p>
<p>Masks bits according to an AND &amp; an OR mask into a single output register (holding register, 4:00000 reference). Masking is done as follows: result = (currentVal AND andMask) OR (orMask AND (NOT andMask))</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255 for serial, 0 - 255 for TCP) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regAddr</em>&nbsp;</td><td>Register address (Range: 1 - 65536) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>andMask</em>&nbsp;</td><td>Mask to be applied as a logic AND to the register </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>orMask</em>&nbsp;</td><td>Mask to be applied as a logic OR to the register </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>

</div>
</div>
<a class="anchor" id="ac6142b852a7760f72daf2ec649f986b0"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::readWriteRegisters" ref="ac6142b852a7760f72daf2ec649f986b0" args="(int slaveAddr, int readRef, short readArr[], int readCnt, int writeRef, const short writeArr[], int writeCnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int readWriteRegisters </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>readRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>readArr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>readCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>writeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short&nbsp;</td>
          <td class="paramname"> <em>writeArr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>writeCnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function 23 (17 Hex), Read/Write Registers. </p>
<p>Combines reading and writing of the output registers in one transaction (holding registers, 4:00000 table).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255 for serial, 0 - 255 for TCP) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>readRef</em>&nbsp;</td><td>Start register for reading (Range: 1 - 65536) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>readArr</em>&nbsp;</td><td>Buffer which will contain the data read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>readCnt</em>&nbsp;</td><td>Number of registers to be read (Range: 1-125) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>writeRef</em>&nbsp;</td><td>Start register for writing (Range: 1 - 65536) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>writeArr</em>&nbsp;</td><td>Buffer with data to be sent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>writeCnt</em>&nbsp;</td><td>Number of registers to be written (Range: 1-121) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>

</div>
</div>
<a class="anchor" id="a302b75ea21b9600e30ac68bcf81f64aa"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::readMultipleLongInts" ref="a302b75ea21b9600e30ac68bcf81f64aa" args="(int slaveAddr, int startRef, int int32Arr[], int refCnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int readMultipleLongInts </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>int32Arr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>refCnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function 3 for 32-bit long int data types, Read Holding Registers/Read Multiple Registers as long int data. </p>
<p>Reads the contents of pairs of consecutive output registers (holding registers, 4:00000 table) into 32-bit long int values.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Depending on the 32-bit Mode setting, an int will be transferred as two consecutive 16-bit registers (Standard) or as one 32-bit register (Daniel/Enron). </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 65536) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int32Arr</em>&nbsp;</td><td>Buffer which will be filled with the data read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of long integers to be read (Range: 1-62) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>

</div>
</div>
<a class="anchor" id="a3b323a95f0220f08fb6eec0a0958ea3f"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::readInputLongInts" ref="a3b323a95f0220f08fb6eec0a0958ea3f" args="(int slaveAddr, int startRef, int int32Arr[], int refCnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int readInputLongInts </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>int32Arr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>refCnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function 4 for 32-bit long int data types, Read Input Registers as long int data. </p>
<p>Reads the contents of pairs of consecutive input registers (3:00000 table) into 32-bit long int values.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Depending on the 32-bit Mode setting, an int will be transferred as two consecutive 16-bit registers (Standard) or as one 32-bit register (Daniel/Enron). </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 65536) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int32Arr</em>&nbsp;</td><td>Buffer which will be filled with the data read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of long integers to be read (Range: 1-62) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>

</div>
</div>
<a class="anchor" id="a839f8346ae1b9f4b7fdc7a056789cc83"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::writeMultipleLongInts" ref="a839f8346ae1b9f4b7fdc7a056789cc83" args="(int slaveAddr, int startRef, const int int32Arr[], int refCnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int writeMultipleLongInts </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>int32Arr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>refCnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function 16 (10 Hex) for 32-bit long int data types, Preset Multiple Registers/Write Multiple Registers with long int data. </p>
<p>Writes long int values into pairs of output registers (holding registers, 4:00000 table).</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Depending on the 32-bit Mode setting, an int will be transferred as two consecutive 16-bit registers (Standard) or as one 32-bit register (Daniel/Enron). </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 0 - 255) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 65536) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int32Arr</em>&nbsp;</td><td>Buffer with the data to be sent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of long integers to be sent (Range: 1-61) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Broadcast supported for serial protocols </dd></dl>

</div>
</div>
<a class="anchor" id="acf8eae638c2ce090d5a9fbabfbb065fa"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::readMultipleFloats" ref="acf8eae638c2ce090d5a9fbabfbb065fa" args="(int slaveAddr, int startRef, float float32Arr[], int refCnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int readMultipleFloats </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>float32Arr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>refCnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function 3 for 32-bit float data types, Read Holding Registers/Read Multiple Registers as float data. </p>
<p>Reads the contents of pairs of consecutive output registers (holding registers, 4:00000 table) into float values.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Depending on the 32-bit Mode setting, an int will be transferred as two consecutive 16-bit registers (Standard) or as one 32-bit register (Daniel/Enron). </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 65536) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>float32Arr</em>&nbsp;</td><td>Buffer which will be filled with the data read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of float values to be read (Range: 1-62) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>

</div>
</div>
<a class="anchor" id="a3ec38f6a93fc0027258e4e43c3a68b43"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::readInputFloats" ref="a3ec38f6a93fc0027258e4e43c3a68b43" args="(int slaveAddr, int startRef, float float32Arr[], int refCnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int readInputFloats </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>float32Arr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>refCnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function 4 for 32-bit float data types, Read Input Registers as float data. </p>
<p>Reads the contents of pairs of consecutive input registers (3:00000 table) into float values.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Depending on the 32-bit Mode setting, an int will be transferred as two consecutive 16-bit registers (Standard) or as one 32-bit register (Daniel/Enron). </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 65536) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>float32Arr</em>&nbsp;</td><td>Buffer which will be filled with the data read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of floats to be read (Range: 1-62) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>

</div>
</div>
<a class="anchor" id="a40b6b3ba4f302a9e62e82b754913bfff"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::writeMultipleFloats" ref="a40b6b3ba4f302a9e62e82b754913bfff" args="(int slaveAddr, int startRef, const float float32Arr[], int refCnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int writeMultipleFloats </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>float32Arr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>refCnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function 16 (10 Hex) for 32-bit float data types, Preset Multiple Registers/Write Multiple Registers with float data. </p>
<p>Writes float values into pairs of output registers (holding registers, 4:00000 table).</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Depending on the 32-bit Mode setting, an int will be transferred as two consecutive 16-bit registers (Standard) or as one 32-bit register (Daniel/Enron). </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 0 - 255) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 65536) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>float32Arr</em>&nbsp;</td><td>Buffer with the data to be sent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of float values to be sent (Range: 1-61) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Broadcast supported for serial protocols </dd></dl>

</div>
</div>
<a class="anchor" id="a17196f562a8789d125329ea668589e6b"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::readMultipleMod10000" ref="a17196f562a8789d125329ea668589e6b" args="(int slaveAddr, int startRef, int int32Arr[], int refCnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int readMultipleMod10000 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>int32Arr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>refCnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function 3 for 32-bit modulo-10000 long int data types, Read Holding Registers/Read Multiple Registers as modulo-10000 long int data. </p>
<p>Reads the contents of pairs of consecutive output registers (holding registers, 4:00000 table) representing a modulo-10000 long int value into 32-bit int values and performs number format conversion.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Depending on the 32-bit Mode setting, an int will be transferred as two consecutive 16-bit registers (Standard) or as one 32-bit register (Daniel/Enron). </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 65536) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int32Arr</em>&nbsp;</td><td>Buffer which will be filled with the data read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of M10K integers to be read (Range: 1-62) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>

</div>
</div>
<a class="anchor" id="a38d66906420d8f74d20b39fa3b1ade57"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::readInputMod10000" ref="a38d66906420d8f74d20b39fa3b1ade57" args="(int slaveAddr, int startRef, int int32Arr[], int refCnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int readInputMod10000 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>int32Arr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>refCnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function 4 for 32-bit modulo-10000 long int data types, Read Input Registers as modulo-10000 long int data. </p>
<p>Reads the contents of pairs of consecutive input registers (3:00000 table) representing a modulo-10000 long int value into 32-bit long int values and performs number format conversion.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Depending on the 32-bit Mode setting, an int will be transferred as two consecutive 16-bit registers (Standard) or as one 32-bit register (Daniel/Enron). </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 65536) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int32Arr</em>&nbsp;</td><td>Buffer which will be filled with the data read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of M10K integers to be read (Range: 1-62) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>

</div>
</div>
<a class="anchor" id="a7f5974d79eb38d639c76e4c640de0cbc"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::writeMultipleMod10000" ref="a7f5974d79eb38d639c76e4c640de0cbc" args="(int slaveAddr, int startRef, const int int32Arr[], int refCnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int writeMultipleMod10000 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>startRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>int32Arr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>refCnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function 16 (10 Hex) for 32-bit modulo-10000 long int data types, Preset Multiple Registers/Write Multiple Registers with modulo-10000 long int data. </p>
<p>Writes long int values into pairs of output registers (holding registers, 4:00000 table) representing a modulo-10000 long int value and performs number format conversion.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Depending on the 32-bit Mode setting, an int will be transferred as two consecutive 16-bit registers (Standard) or as one 32-bit register (Daniel/Enron). </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 0 - 255) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startRef</em>&nbsp;</td><td>Start reference (Range: 1 - 65536) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int32Arr</em>&nbsp;</td><td>Buffer with the data to be sent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCnt</em>&nbsp;</td><td>Number of long integer values to be sent (Range: 1-61) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Broadcast supported for serial protocols </dd></dl>

</div>
</div>
<a class="anchor" id="a751949db73e8409dca8409b108aee2ae"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::readExceptionStatus" ref="a751949db73e8409dca8409b108aee2ae" args="(int slaveAddr, unsigned char *statusBytePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int readExceptionStatus </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>statusBytePtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function 7, Read Exception Status. </p>
<p>Reads the eight exception status coils within the slave device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255 for serial, 0 - 255 for TCP) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>statusBytePtr</em>&nbsp;</td><td>Slave status byte. The meaning of this status byte is slave specific and varies from device to device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>

</div>
</div>
<a class="anchor" id="acdd4287c493dda9db1995ea86139328f"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::returnQueryData" ref="acdd4287c493dda9db1995ea86139328f" args="(int slaveAddr, const unsigned char queryArr[], unsigned char echoArr[], int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int returnQueryData </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&nbsp;</td>
          <td class="paramname"> <em>queryArr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>echoArr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function code 8, sub-function 00, Return Query Data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255 for serial, 0 - 255 for TCP) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>queryArr</em>&nbsp;</td><td>Buffer with data to be sent </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>echoArr</em>&nbsp;</td><td>Buffer which will contain the data read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Number of bytes send sent and read back </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success, FTALK_INVALID_REPLY_ERROR if reply does not match query data or error code. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>

</div>
</div>
<a class="anchor" id="a52e7edd849a2b1f7c29ac9517bdd1d3d"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::restartCommunicationsOption" ref="a52e7edd849a2b1f7c29ac9517bdd1d3d" args="(int slaveAddr, int clearEventLog)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int restartCommunicationsOption </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>clearEventLog</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modbus function code 8, sub-function 01, Restart Communications Option. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255 for serial, 0 - 255 for TCP) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clearEventLog</em>&nbsp;</td><td>Flag when set to one clears in addition the slave's communication even log. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FTALK_SUCCESS on success. See <a class="el" href="group__buserror.html">Error Management</a> for a list of error codes. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>No broadcast supported </dd></dl>

</div>
</div>
<a class="anchor" id="a0649ac6aee01f23c07b9b747f3d33d1d"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::setTimeout" ref="a0649ac6aee01f23c07b9b747f3d33d1d" args="(int timeOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int setTimeout </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>msTime</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures time-out. </p>
<p>This function sets the operation or socket time-out to the specified value.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The time-out value is indicative only and not guaranteed to be maintained. How precise it is followed depends on the operating system used, it's scheduling priority and it's system timer resolution. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>A protocol must be closed in order to configure it. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msTime</em>&nbsp;</td><td>Timeout value in ms (Range: 1 - 100000) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>FTALK_SUCCESS</em>&nbsp;</td><td>Success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FTALK_ILLEGAL_ARGUMENT_ERROR</em>&nbsp;</td><td>Argument out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FTALK_ILLEGAL_STATE_ERROR</em>&nbsp;</td><td>Protocol is already open </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a556668ae26748c5d696c34d3915e08d8"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::getTimeout" ref="a556668ae26748c5d696c34d3915e08d8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getTimeout </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the time-out value. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The time-out value is indicative only and not guaranteed to be maintained. How precise it is followed depends on the operating system used, it's scheduling priority and it's system timer resolution. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Timeout value in ms </dd></dl>

</div>
</div>
<a class="anchor" id="a439626d88c98d2941978b1decb114984"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::setPollDelay" ref="a439626d88c98d2941978b1decb114984" args="(int pollDelay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int setPollDelay </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>msTime</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures poll delay. </p>
<p>This function sets the delay time which applies between two consecutive Modbus read/write. A value of 0 disables the poll delay.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The delay value is indicative only and not guaranteed to be maintained. How precise it is followed depends on the operating system used, it's scheduling priority and it's system timer resolution. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>A protocol must be closed in order to configure it. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msTime</em>&nbsp;</td><td>Delay time in ms (Range: 0 - 100000), 0 disables poll delay </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>FTALK_SUCCESS</em>&nbsp;</td><td>Success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FTALK_ILLEGAL_ARGUMENT_ERROR</em>&nbsp;</td><td>Argument out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FTALK_ILLEGAL_STATE_ERROR</em>&nbsp;</td><td>Protocol is already open </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5298559d8c7d33668e770b28c302455"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::getPollDelay" ref="ac5298559d8c7d33668e770b28c302455" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getPollDelay </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the poll delay time. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Delay time in ms, 0 if poll delay is switched off </dd></dl>

</div>
</div>
<a class="anchor" id="a7a86879ac5b1dcf109a1d1ea8f2e3f0a"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::setRetryCnt" ref="a7a86879ac5b1dcf109a1d1ea8f2e3f0a" args="(int retryCnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int setRetryCnt </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>retries</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures the automatic retry setting. </p>
<p>A value of 0 disables any automatic retries. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>A protocol must be closed in order to configure it.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>retries</em>&nbsp;</td><td>Retry count (Range: 0 - 10), 0 disables retries </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>FTALK_SUCCESS</em>&nbsp;</td><td>Success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FTALK_ILLEGAL_ARGUMENT_ERROR</em>&nbsp;</td><td>Argument out of range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FTALK_ILLEGAL_STATE_ERROR</em>&nbsp;</td><td>Protocol is already open </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4679ad5a7cde6025d751b0632f21cec6"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::getRetryCnt" ref="a4679ad5a7cde6025d751b0632f21cec6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getRetryCnt </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the automatic retry count. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Retry count </dd></dl>

</div>
</div>
<a class="anchor" id="ad1bbef1bb8daa45af22ce3c6983abce0"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::getTotalCounter" ref="ad1bbef1bb8daa45af22ce3c6983abce0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long getTotalCounter </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns how often a message transfer has been executed. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Counter value </dd></dl>

</div>
</div>
<a class="anchor" id="aa5f7d2ae6cb4ed984ea3b637d3fb4b16"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::getSuccessCounter" ref="aa5f7d2ae6cb4ed984ea3b637d3fb4b16" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long getSuccessCounter </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns how often a message transfer was successful. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Counter value </dd></dl>

</div>
</div>
<a class="anchor" id="a6d82a9ee44f44c8f6a7a19a652315c76"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::configureBigEndianInts" ref="a6d82a9ee44f44c8f6a7a19a652315c76" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void configureBigEndianInts </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures 32-bit int data type functions to do a word swap. </p>
<p>Modbus is using little-endian word order for 32-bit values. The data transfer functions operating upon 32-bit int data types can be configured to do a word swap which enables them to read 32-bit data correctly from a big-endian slave. </p>

</div>
</div>
<a class="anchor" id="aebdf07bc15ac25499253c821651d063b"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::configureBigEndianInts" ref="aebdf07bc15ac25499253c821651d063b" args="(int slaveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int configureBigEndianInts </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables int data type functions to do a word swap on a per slave basis. </p>
<p>Modbus is using little-endian word order for 32-bit values. The data transfer functions operating upon 32-bit int data types can be configured to do a word swap which enables them to read 32-bit data correctly from a big-endian machine.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255). A value of zero configures the behaviour for broadcasting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abbc17750cdbd2129d8942170ccb14b0f"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::configureLittleEndianInts" ref="abbc17750cdbd2129d8942170ccb14b0f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void configureLittleEndianInts </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures 32-bit int data type functions not to do a word swap. </p>
<p>This is the default. </p>

</div>
</div>
<a class="anchor" id="a0436a1d520aab4d036e5ceb37511a467"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::configureLittleEndianInts" ref="a0436a1d520aab4d036e5ceb37511a467" args="(int slaveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int configureLittleEndianInts </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disables word swapping for int data type functions on a per slave basis. </p>
<p>Modbus is using little-endian word order for 32-bit values. This setting assumes that the slave also serves 32-bit data in little little-endian word order.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the default mode</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255). A value of zero configures the behaviour for broadcasting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16e0221a03f033b8bfe15f8b09c99116"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::configureIeeeFloats" ref="a16e0221a03f033b8bfe15f8b09c99116" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void configureIeeeFloats </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures float data type functions not to do a word swap. </p>
<p>This is the default. </p>

</div>
</div>
<a class="anchor" id="a64b84ced2ebcbd3e91000b6fca74af94"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::configureIeeeFloats" ref="a64b84ced2ebcbd3e91000b6fca74af94" args="(int slaveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int configureIeeeFloats </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disables float data type functions to do a word swap on a per slave basis. </p>
<p>Modbus is using little-endian word order for 32-bit values. This setting assumes that the slave also serves 32-bit floats in little little-endian word order which is the most common case.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the default mode</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255). A value of zero configures the behaviour for broadcasting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64bd8d4a1c2ab7addee3af912b107ea0"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::configureSwappedFloats" ref="a64bd8d4a1c2ab7addee3af912b107ea0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void configureSwappedFloats </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures float data type functions to do a word swap. </p>
<p>The data functions operating upon 32-bit float data types can be configured to do a word swap. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Most platforms store floats in IEEE 754 little-endian order which does not need a word swap. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b0d3e8e4d5d25ce75cfa648dff74218"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::configureSwappedFloats" ref="a1b0d3e8e4d5d25ce75cfa648dff74218" args="(int slaveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int configureSwappedFloats </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables float data type functions to do a word swap on a per slave basis. </p>
<p>The data functions operating upon 32-bit float data types can be configured to do a word swap. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Most platforms store floats in IEEE 754 little-endian order which does not need a word swap.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255). A value of zero configures the behaviour for broadcasting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a27d2907a8eafa965e3e1c701c7ba67bc"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::configureStandard32BitMode" ref="a27d2907a8eafa965e3e1c701c7ba67bc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void configureStandard32BitMode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures all slaves for Standard 32-bit Mode. </p>
<p>In Standard 32-bit Register Mode a 32-bit value is transmitted as two consecutive 16-bit Modbus registers.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the default mode </dd></dl>

</div>
</div>
<a class="anchor" id="a1de5e0b6a1dd522b00203ab602e7b028"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::configureStandard32BitMode" ref="a1de5e0b6a1dd522b00203ab602e7b028" args="(int slaveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int configureStandard32BitMode </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures a slave for Standard 32-bit Register Mode. </p>
<p>In Standard 32-bit Register Mode a 32-bit value is transmitted as two consecutive 16-bit Modbus registers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255). A value of zero configures the behaviour for broadcasting. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>FTALK_SUCCESS</em>&nbsp;</td><td>Success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FTALK_ILLEGAL_ARGUMENT_ERROR</em>&nbsp;</td><td>Argument out of range</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the default mode </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function call also re-configures the endianess to default little-endian for 32-bit values! </dd></dl>

</div>
</div>
<a class="anchor" id="a61e1bd556bba1708e1465a44ad8701cc"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::configureEnron32BitMode" ref="a61e1bd556bba1708e1465a44ad8701cc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void configureEnron32BitMode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures all slaves for Daniel/ENRON 32-bit Mode. </p>
<p>Some Modbus flavours like the Daniel/Enron protocol represent a 32-bit value using one 32-bit Modbus register instead of two 16-bit registers. </p>

</div>
</div>
<a class="anchor" id="a2010cf27a82c4ab4f82e2ecf32466dd2"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::configureEnron32BitMode" ref="a2010cf27a82c4ab4f82e2ecf32466dd2" args="(int slaveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int configureEnron32BitMode </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures all slaves for Daniel/ENRON 32-bit Mode. </p>
<p>Some Modbus flavours like the Daniel/Enron protocol represent a 32-bit value using one 32-bit Modbus register instead of two 16-bit registers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255). A value of zero configures the behaviour for broadcasting. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>FTALK_SUCCESS</em>&nbsp;</td><td>Success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FTALK_ILLEGAL_ARGUMENT_ERROR</em>&nbsp;</td><td>Argument out of range </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function call also re-configures the endianess to big-endian for 32-bit values as defined by the Daniel/ENRON protocol! </dd></dl>

</div>
</div>
<a class="anchor" id="a3de968ddddba3bf894ac8b5a154eb720"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::configureCountFromOne" ref="a3de968ddddba3bf894ac8b5a154eb720" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void configureCountFromOne </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures the reference counting scheme to start with one for all slaves. </p>
<p>This renders the reference range to be 1 to 0x10000 and register #0 is an illegal register.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the default mode </dd></dl>

</div>
</div>
<a class="anchor" id="ad4f702a085577c924e63388b5a9a5d62"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::configureCountFromOne" ref="ad4f702a085577c924e63388b5a9a5d62" args="(int slaveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int configureCountFromOne </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures a slave's reference counting scheme to start with one. </p>
<p>This renders the reference range to be 1 to 0x10000 and register #0 is an illegal register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255). A value of zero configures the behaviour for broadcasting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This is the default mode </dd></dl>

</div>
</div>
<a class="anchor" id="a7e541835ede7552fa6f603e5263d8c97"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::configureCountFromZero" ref="a7e541835ede7552fa6f603e5263d8c97" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void configureCountFromZero </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures the reference counting scheme to start with zero for all slaves. </p>
<p>This renders the valid reference range to be 0 to 0xFFFF.</p>
<p>This renders the first register to be #0 for all slaves. </p>

</div>
</div>
<a class="anchor" id="a35d29523ba52fe3df3a92858957ea49e"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::configureCountFromZero" ref="a35d29523ba52fe3df3a92858957ea49e" args="(int slaveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int configureCountFromZero </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>slaveAddr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Configures a slave's reference counting scheme to start with zero. </p>
<p>This is also known as PDU addressing.</p>
<p>This renders the valid reference range to be 0 to 0xFFFF.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>slaveAddr</em>&nbsp;</td><td>Modbus address of slave device or unit identifier (Range: 1 - 255). A value of zero configures the behaviour for broadcasting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a663f47b96550118a11ef583bc33e27bf"></a><!-- doxytag: member="MbusRtuOverTcpMasterProtocol::getPackageVersion" ref="a663f47b96550118a11ef583bc33e27bf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const TCHAR * getPackageVersion </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the library version number. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Library version string </dd></dl>

</div>
</div>
</div>
<hr size="1"><address style="text-align: right;">
<small>
FieldTalk Modbus Master C++ Library
<br>
Draft Version
</small></address>
</body>
</html>

